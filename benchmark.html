<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostWind Performance Benchmark</title>
</head>
<body class="dw-body">
    <main class="dw-page">
        <header class="dw-hero">
            <p class="dw-eyebrow">Labs benchmark</p>
            <h1 class="dw-hero-title">PostWind vs Tailwind Performance</h1>
            <p class="dw-hero-copy">
                Quick synthetic tests that simulate typical PostWind workloads. Run each suite
                individually or trigger all three to capture a holistic snapshot.
            </p>
            <div class="dw-hero-actions">
                <button id="run-all" class="dw-btn dw-btn-primary">▶ Run all benchmarks</button>
                <button id="reset-results" class="dw-btn dw-btn-secondary">↺ Reset results</button>
            </div>
        </header>

        <section class="dw-card-grid">
            <article class="dw-card">
                <div class="dw-card-head">
                    <p class="dw-card-eyebrow">Test 01</p>
                    <h3 class="dw-card-title">Generate 100 unique classes</h3>
                    <p class="dw-card-copy">Measures how fast on-demand class generation performs versus shipping a static CSS bundle.</p>
                </div>
                <button id="btn-generation" class="dw-btn dw-btn-primary">Run class generator</button>
                <div id="generation-results" class="dw-result" aria-live="polite"></div>
            </article>

            <article class="dw-card">
                <div class="dw-card-head">
                    <p class="dw-card-eyebrow">Test 02</p>
                    <h3 class="dw-card-title">Process 1000 DOM nodes</h3>
                    <p class="dw-card-copy">Simulates the DOM observer scanning for utility classes in a moderately sized UI subtree.</p>
                </div>
                <button id="btn-dom" class="dw-btn dw-btn-primary">Run DOM sweep</button>
                <div id="dom-results" class="dw-result" aria-live="polite"></div>
            </article>

            <article class="dw-card">
                <div class="dw-card-head">
                    <p class="dw-card-eyebrow">Test 03</p>
                    <h3 class="dw-card-title">Memory footprint</h3>
                    <p class="dw-card-copy">Leverages the experimental Memory API (Chrome only) to approximate runtime cache usage.</p>
                </div>
                <button id="btn-memory" class="dw-btn dw-btn-primary">Run memory sample</button>
                <div id="memory-results" class="dw-result" aria-live="polite"></div>
            </article>
        </section>
    </main>

    <script type="module">
        import PostWind from "./src/lib.js";

        PostWind.init();

        PostWind.define({
            'shadow-pill': 'box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);',
            'shadow-pill-soft': 'box-shadow: 0 10px 18px rgba(37, 99, 235, 0.12);',
            'shadow-card': 'box-shadow: 0 25px 45px rgba(15, 23, 42, 0.08);',
            'shadow-result': 'box-shadow: 0 20px 40px rgba(59, 130, 246, 0.18);',
            'shadow-chip': 'box-shadow: 0 10px 20px rgba(15, 23, 42, 0.05);',

            'dw-body': 'font-sans bg-slate-100 text-slate-900 min-h-screen flex justify-center px-4 py-10',
            'dw-page': 'w-full max-w-5xl flex flex-col gap-10',
            'dw-hero': 'text-center flex flex-col gap-4 items-center',
            'dw-eyebrow': 'uppercase text-xs font-semibold tracking-[0.3em] text-blue-600',
            'dw-hero-title': 'text-3xl font-bold text-slate-900',
            'dw-hero-copy': 'text-base text-slate-600 leading-relaxed max-w-2xl mx-[auto]',
            'dw-hero-actions': 'flex flex-wrap items-center justify-center gap-4',
            'dw-btn': 'inline-flex items-center gap-2 rounded-full px-6 py-2 font-semibold transition duration-150 ease-out active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed',
            'dw-btn-primary': 'dw-btn bg-blue-600 text-white shadow-pill hover:bg-blue-500',
            'dw-btn-secondary': 'dw-btn border border-blue-500 text-blue-700 bg-white hover:bg-blue-50 shadow-pill-soft',
            'dw-card-grid': 'w-full grid grid-cols-1 gap-6 t:grid-cols-2 d:grid-cols-3',
            'dw-card': 'bg-white border rounded-[28px] p-6 shadow-card flex flex-col gap-4 h-full',
            'dw-card-head': 'flex flex-col gap-2 text-left',
            'dw-card-eyebrow': 'text-blue-600 text-xs font-semibold uppercase tracking-[0.3em]',
            'dw-card-title': 'text-lg font-semibold text-slate-900',
            'dw-card-copy': 'text-sm text-slate-500 leading-relaxed',
            'dw-result': 'rounded-[26px] border bg-blue-50 p-5 font-mono text-sm text-slate-800 flex flex-col gap-4 whitespace-pre-wrap min-h-[8rem] shadow-result',
            'dw-result-grid': 'grid grid-cols-1 gap-3 t:grid-cols-2',
            'dw-result-cell': 'bg-white rounded-[18px] border px-3 py-2 flex flex-col gap-1 shadow-chip',
            'dw-result-cell-label': 'text-xs uppercase tracking-[0.3em] text-slate-400',
            'dw-result-cell-value': 'text-lg font-semibold text-slate-900',
            'dw-result-winner': 'text-base font-semibold text-slate-900',
            'dw-comparison': 'list-disc list-inside text-slate-500 text-sm',
            'dw-comparison-item': 'mt-2 first:mt-0',
            'dw-note': 'text-xs text-slate-400'
        });

        const formatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2 });
        const generationTarget = 100;

        const defaultMessages = {
            generation: 'Waiting to generate utility classes…',
            dom: 'Benchmark idle. Add DOM load when ready.',
            memory: 'Memory sampling only works in Chromium-based browsers.',
        };

        Object.entries(defaultMessages).forEach(([key, value]) => {
            const el = document.getElementById(`${key}-results`);
            if (el) el.textContent = value;
        });

        const setButtonBusy = (button, busy) => {
            if (!button) return;
            button.disabled = busy;
            button.dataset.originalLabel = button.dataset.originalLabel || button.textContent;
            button.textContent = busy ? 'Running…' : button.dataset.originalLabel;
        };

        const renderResults = (targetId, summary) => {
            const el = document.getElementById(targetId);
            if (!el) return;
            const statsHtml = summary.stats
                .map(({ label, value }) => `
                    <div class="dw-result-cell">
                        <span class="dw-result-cell-label">${label}</span>
                        <span class="dw-result-cell-value">${value}</span>
                    </div>
                `)
                .join('');
            const comparisonHtml = summary.comparison
                .map(item => `<li class="dw-comparison-item">${item}</li>`)
                .join('');

            el.innerHTML = `
                <div class="dw-result-grid">${statsHtml}</div>
                <p class="dw-result-winner">Winner: ${summary.winner}</p>
                <ul class="dw-comparison">${comparisonHtml}</ul>
                <p class="dw-note">${summary.note}</p>
            `;
        };

        const generateClassList = () => {
            const seed = [
                'p-1', 'p-2', 'p-4', 'p-8', 'p-16',
                'm-1', 'm-2', 'm-4', 'm-8', 'm-16',
                'bg-red-500', 'bg-blue-500', 'bg-green-500',
                'text-xs', 'text-sm', 'text-lg', 'text-xl',
                'flex', 'grid', 'hidden', 'block',
                'justify-center', 'items-center',
                'rounded', 'rounded-lg', 'rounded-full',
                'border', 'border-2', 'border-4',
                'shadow', 'shadow-lg', 'shadow-xl',
            ];

            const classes = new Set(seed);
            let i = 0;
            while (classes.size < generationTarget) {
                classes.add(`w-${i}`);
                if (classes.size >= generationTarget) break;
                classes.add(`h-${i}`);
                if (classes.size >= generationTarget) break;
                classes.add(`text-${++i}px`);
            }
            return [...classes];
        };

        async function benchmarkGeneration() {
            const button = document.getElementById('btn-generation');
            setButtonBusy(button, true);
            const classList = generateClassList();
            const start = performance.now();
            classList.forEach(cls => PostWind.loadClass(cls));
            const duration = performance.now() - start;
            const average = duration / classList.length;

            renderResults('generation-results', {
                stats: [
                    { label: 'Classes', value: classList.length },
                    { label: 'Total time', value: `${formatter.format(duration)} ms` },
                    { label: 'Avg/class', value: `${formatter.format(average)} ms` },
                    { label: 'Throughput', value: `${Math.round(1000 / average)} cls/sec` },
                ],
                comparison: [
                    `PostWind generated on-demand in ${formatter.format(duration)} ms`,
                    'Tailwind ships ~50-200 ms worth of CSS upfront',
                    'Ideal workflow depends on cache priming',
                ],
                winner: duration < 50 ? 'PostWind (cold start)' : 'Tailwind (prebuilt)',
                note: 'Synthetic micro-benchmark. Real projects may vary with caching + hydration.',
            });

            setButtonBusy(button, false);
        }

        async function benchmarkDOMProcessing() {
            const button = document.getElementById('btn-dom');
            setButtonBusy(button, true);
            const container = document.createElement('section');
            container.hidden = true;
            document.body.appendChild(container);

            const classOptions = ['p-4', 'bg-blue-100', 'text-center', 'rounded', 'border', 'shadow'];
            const start = performance.now();

            for (let i = 0; i < 1000; i++) {
                const div = document.createElement('div');
                div.className = classOptions.filter(() => Math.random() > 0.5).join(' ');
                div.textContent = `Element ${i}`;
                container.appendChild(div);
            }

            container.querySelectorAll('[class]').forEach(el => {
                el.className.split(/\s+/).forEach(cls => {
                    if (cls) PostWind.loadClass(cls);
                });
            });

            const duration = performance.now() - start;
            const average = duration / 1000;

            renderResults('dom-results', {
                stats: [
                    { label: 'Elements', value: '1,000' },
                    { label: 'Total time', value: `${formatter.format(duration)} ms` },
                    { label: 'Avg/element', value: `${formatter.format(average)} ms` },
                    { label: 'Observer cost', value: average < 1 ? 'Low' : 'Moderate' },
                ],
                comparison: [
                    `PostWind generated + applied in ${formatter.format(duration)} ms`,
                    'Tailwind only applies classes (~5-20 ms)',
                    'Winner changes with DOM churn + caching',
                ],
                winner: duration < 20 ? 'PostWind' : 'Tailwind',
                note: 'Processing includes synthetic DOM creation overhead.',
            });

            container.remove();
            setButtonBusy(button, false);
        }

        async function benchmarkMemory() {
            const button = document.getElementById('btn-memory');
            setButtonBusy(button, true);

            if (!performance.memory) {
                renderResults('memory-results', {
                    stats: [
                        { label: 'API support', value: 'Unavailable' },
                        { label: 'Samples', value: 0 },
                        { label: 'Heap delta', value: 'N/A' },
                        { label: 'Winner', value: 'Undetermined' },
                    ],
                    comparison: [
                        'Chrome + Edge expose performance.memory',
                        'Firefox/Safari block direct heap sampling',
                        'Use DevTools for manual memory traces',
                    ],
                    winner: 'Feature not supported',
                    note: 'Try Chromium for automated heap sampling.',
                });
                setButtonBusy(button, false);
                return;
            }

            const before = performance.memory.usedJSHeapSize;
            for (let i = 0; i < 500; i++) {
                PostWind.loadClass(`test-class-${i}`);
                PostWind.loadClass(`bg-color-${i}`);
                PostWind.loadClass(`p-${i % 20}`);
            }
            const after = performance.memory.usedJSHeapSize;
            const deltaKB = (after - before) / 1024;

            renderResults('memory-results', {
                stats: [
                    { label: 'Classes cached', value: '≈1,500' },
                    { label: 'Heap delta', value: `${formatter.format(deltaKB)} KB` },
                    { label: 'Per class', value: `${formatter.format(deltaKB / 1500)} KB` },
                    { label: 'Runtime', value: '< 5 ms' },
                ],
                comparison: [
                    `PostWind cache delta ~${formatter.format(deltaKB)} KB`,
                    'Tailwind (purged) ships 5-15 KB upfront',
                    'Tailwind (full) ~3.5 MB of CSS',
                ],
                winner: deltaKB < 100 ? 'PostWind cache' : 'Tailwind (purged)',
                note: 'Heap sampling is approximate; run multiple times for stability.',
            });

            setButtonBusy(button, false);
        }

        async function runAllBenchmarks() {
            const masterButton = document.getElementById('run-all');
            setButtonBusy(masterButton, true);
            await benchmarkGeneration();
            await benchmarkDOMProcessing();
            await benchmarkMemory();
            setButtonBusy(masterButton, false);
        }

        const wireButton = (id, handler) => {
            const el = document.getElementById(id);
            if (el) el.addEventListener('click', handler);
        };

        wireButton('btn-generation', benchmarkGeneration);
        wireButton('btn-dom', benchmarkDOMProcessing);
        wireButton('btn-memory', benchmarkMemory);
        wireButton('run-all', runAllBenchmarks);
        wireButton('reset-results', () => {
            Object.entries(defaultMessages).forEach(([key, value]) => {
                const el = document.getElementById(`${key}-results`);
                if (el) el.textContent = value;
            });
        });

        window.benchmarkGeneration = benchmarkGeneration;
        window.benchmarkDOMProcessing = benchmarkDOMProcessing;
        window.benchmarkMemory = benchmarkMemory;
    </script>
</body>
</html>
